/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["b4"] = factory();
	else
		root["b4"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/bg/b4.js":
/*!*************************!*\
  !*** ./src/js/bg/b4.js ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\ndocument.writeln(\"<canvas id='bg_canvas' style='width:100%;height:100%;position:fixed;top:0;left:0;z-index:-1;background: #000 url(\".concat(Integration_LocalConst.STATIC_PATH, \"images/bgCanvas.jpg) repeat;'></canvas>\"));\n\n(function (name, factory) {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") {\n    window[name] = factory();\n  }\n})(\"Ribbons\", function () {\n  var _w = window,\n      _b = document.body,\n      _d = document.documentElement;\n\n  var random = function random() {\n    if (arguments.length === 1) {\n      if (Array.isArray(arguments[0])) {\n        var index = Math.round(random(0, arguments[0].length - 1));\n        return arguments[0][index];\n      }\n\n      return random(0, arguments[0]);\n    } else if (arguments.length === 2) {\n      return Math.random() * (arguments[1] - arguments[0]) + arguments[0];\n    }\n\n    return 0;\n  };\n\n  var screenInfo = function screenInfo(e) {\n    var width = Math.max(0, _w.innerWidth || _d.clientWidth || _b.clientWidth || 0),\n        height = Math.max(0, _w.innerHeight || _d.clientHeight || _b.clientHeight || 0),\n        scrollx = Math.max(0, _w.pageXOffset || _d.scrollLeft || _b.scrollLeft || 0) - (_d.clientLeft || 0),\n        scrolly = Math.max(0, _w.pageYOffset || _d.scrollTop || _b.scrollTop || 0) - (_d.clientTop || 0);\n    return {\n      width: width,\n      height: height,\n      ratio: width / height,\n      centerx: width / 2,\n      centery: height / 2,\n      scrollx: scrollx,\n      scrolly: scrolly\n    };\n  };\n\n  var mouseInfo = function mouseInfo(e) {\n    var screen = screenInfo(e),\n        mousex = e ? Math.max(0, e.pageX || e.clientX || 0) : 0,\n        mousey = e ? Math.max(0, e.pageY || e.clientY || 0) : 0;\n    return {\n      mousex: mousex,\n      mousey: mousey,\n      centerx: mousex - screen.width / 2,\n      centery: mousey - screen.height / 2\n    };\n  };\n\n  var Point = function Point(x, y) {\n    this.x = 0;\n    this.y = 0;\n    this.set(x, y);\n  };\n\n  Point.prototype = {\n    constructor: Point,\n    set: function set(x, y) {\n      this.x = x || 0;\n      this.y = y || 0;\n    },\n    copy: function copy(point) {\n      this.x = point.x || 0;\n      this.y = point.y || 0;\n      return this;\n    },\n    multiply: function multiply(x, y) {\n      this.x *= x || 1;\n      this.y *= y || 1;\n      return this;\n    },\n    divide: function divide(x, y) {\n      this.x /= x || 1;\n      this.y /= y || 1;\n      return this;\n    },\n    add: function add(x, y) {\n      this.x += x || 0;\n      this.y += y || 0;\n      return this;\n    },\n    subtract: function subtract(x, y) {\n      this.x -= x || 0;\n      this.y -= y || 0;\n      return this;\n    },\n    clampX: function clampX(min, max) {\n      this.x = Math.max(min, Math.min(this.x, max));\n      return this;\n    },\n    clampY: function clampY(min, max) {\n      this.y = Math.max(min, Math.min(this.y, max));\n      return this;\n    },\n    flipX: function flipX() {\n      this.x *= -1;\n      return this;\n    },\n    flipY: function flipY() {\n      this.y *= -1;\n      return this;\n    }\n  };\n\n  var Factory = function Factory(options) {\n    this._canvas = null;\n    this._context = null;\n    this._sto = null;\n    this._width = 0;\n    this._height = 0;\n    this._scroll = 0;\n    this._ribbons = [];\n    this._options = {\n      colorSaturation: \"100%\",\n      colorBrightness: \"60%\",\n      colorAlpha: 0.80,\n      colorCycleSpeed: 8,\n      verticalPosition: \"center\",\n      horizontalSpeed: 200,\n      ribbonCount: 5,\n      strokeSize: 0,\n      parallaxAmount: -0.0,\n      animateSections: true\n    };\n    this._onDraw = this._onDraw.bind(this);\n    this._onResize = this._onResize.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this.setOptions(options);\n    this.init();\n  };\n\n  Factory.prototype = {\n    constructor: Factory,\n    setOptions: function setOptions(options) {\n      if (_typeof(options) === \"object\") {\n        for (var key in options) {\n          if (options.hasOwnProperty(key)) {\n            this._options[key] = options[key];\n          }\n        }\n      }\n    },\n    init: function init() {\n      try {\n        this._canvas = document.createElement(\"canvas\");\n        this._canvas.style[\"display\"] = \"block\";\n        this._canvas.style[\"position\"] = \"fixed\";\n        this._canvas.style[\"margin\"] = \"0\";\n        this._canvas.style[\"padding\"] = \"0\";\n        this._canvas.style[\"border\"] = \"0\";\n        this._canvas.style[\"outline\"] = \"0\";\n        this._canvas.style[\"left\"] = \"0\";\n        this._canvas.style[\"top\"] = \"0\";\n        this._canvas.style[\"width\"] = \"100%\";\n        this._canvas.style[\"height\"] = \"100%\";\n        this._canvas.style[\"z-index\"] = \"-1\";\n        this._canvas.id = \"bg_canvas\";\n\n        this._onResize();\n\n        this._context = this._canvas.getContext(\"2d\");\n\n        this._context.clearRect(0, 0, this._width, this._height);\n\n        this._context.globalAlpha = this._options.colorAlpha;\n        window.addEventListener(\"resize\", this._onResize);\n        window.addEventListener(\"scroll\", this._onScroll);\n        document.body.appendChild(this._canvas);\n      } catch (e) {\n        console.warn(\"Canvas Context Error: \" + e.toString());\n        return;\n      }\n\n      this._onDraw();\n    },\n    addRibbon: function addRibbon() {\n      var dir = Math.round(random(1, 9)) > 5 ? \"right\" : \"left\",\n          stop = 1000,\n          hide = 200,\n          min = 0 - hide,\n          max = this._width + hide,\n          movex = 0,\n          movey = 0,\n          startx = dir === \"right\" ? min : max,\n          starty = Math.round(random(0, this._height));\n\n      if (/^(top|min)$/i.test(this._options.verticalPosition)) {\n        starty = 0 + hide;\n      } else if (/^(middle|center)$/i.test(this._options.verticalPosition)) {\n        starty = this._height / 2;\n      } else if (/^(bottom|max)$/i.test(this._options.verticalPosition)) {\n        starty = this._height - hide;\n      }\n\n      var ribbon = [],\n          point1 = new Point(startx, starty),\n          point2 = new Point(startx, starty),\n          point3 = null,\n          color = Math.round(random(0, 360)),\n          delay = 0;\n\n      while (true) {\n        if (stop <= 0) break;\n        stop--;\n        movex = Math.round((Math.random() * 1 - 0.2) * this._options.horizontalSpeed);\n        movey = Math.round((Math.random() * 1 - 0.5) * (this._height * 0.25));\n        point3 = new Point();\n        point3.copy(point2);\n\n        if (dir === \"right\") {\n          point3.add(movex, movey);\n          if (point2.x >= max) break;\n        } else if (dir === \"left\") {\n          point3.subtract(movex, movey);\n          if (point2.x <= min) break;\n        }\n\n        ribbon.push({\n          point1: new Point(point1.x, point1.y),\n          point2: new Point(point2.x, point2.y),\n          point3: point3,\n          color: color,\n          delay: delay,\n          dir: dir,\n          alpha: 0,\n          phase: 0\n        });\n        point1.copy(point2);\n        point2.copy(point3);\n        delay += 4;\n        color += this._options.colorCycleSpeed;\n      }\n\n      this._ribbons.push(ribbon);\n    },\n    _drawRibbonSection: function _drawRibbonSection(section) {\n      if (section) {\n        if (section.phase >= 1 && section.alpha <= 0) {\n          return true;\n        }\n\n        if (section.delay <= 0) {\n          section.phase += 0.02;\n          section.alpha = Math.sin(section.phase) * 1;\n          section.alpha = section.alpha <= 0 ? 0 : section.alpha;\n          section.alpha = section.alpha >= 1 ? 1 : section.alpha;\n\n          if (this._options.animateSections) {\n            var mod = Math.sin(1 + section.phase * Math.PI / 2) * 0.1;\n\n            if (section.dir === \"right\") {\n              section.point1.add(mod, 0);\n              section.point2.add(mod, 0);\n              section.point3.add(mod, 0);\n            } else {\n              section.point1.subtract(mod, 0);\n              section.point2.subtract(mod, 0);\n              section.point3.subtract(mod, 0);\n            }\n\n            section.point1.add(0, mod);\n            section.point2.add(0, mod);\n            section.point3.add(0, mod);\n          }\n        } else {\n          section.delay -= 0.5;\n        }\n\n        var s = this._options.colorSaturation,\n            l = this._options.colorBrightness,\n            c = \"hsla(\" + section.color + \", \" + s + \", \" + l + \", \" + section.alpha + \" )\";\n\n        this._context.save();\n\n        if (this._options.parallaxAmount !== 0) {\n          this._context.translate(0, this._scroll * this._options.parallaxAmount);\n        }\n\n        this._context.beginPath();\n\n        this._context.moveTo(section.point1.x, section.point1.y);\n\n        this._context.lineTo(section.point2.x, section.point2.y);\n\n        this._context.lineTo(section.point3.x, section.point3.y);\n\n        this._context.fillStyle = c;\n\n        this._context.fill();\n\n        if (this._options.strokeSize > 0) {\n          this._context.lineWidth = this._options.strokeSize;\n          this._context.strokeStyle = c;\n          this._context.lineCap = \"round\";\n\n          this._context.stroke();\n        }\n\n        this._context.restore();\n      }\n\n      return false;\n    },\n    _onDraw: function _onDraw() {\n      for (var i = 0, t = this._ribbons.length; i < t; ++i) {\n        if (!this._ribbons[i]) {\n          this._ribbons.splice(i, 1);\n        }\n      }\n\n      this._context.clearRect(0, 0, this._width, this._height);\n\n      for (var a = 0; a < this._ribbons.length; ++a) {\n        var ribbon = this._ribbons[a],\n            numSections = ribbon.length,\n            numDone = 0;\n\n        for (var b = 0; b < numSections; ++b) {\n          if (this._drawRibbonSection(ribbon[b])) {\n            numDone++;\n          }\n        }\n\n        if (numDone >= numSections) {\n          this._ribbons[a] = null;\n        }\n      }\n\n      if (this._ribbons.length < this._options.ribbonCount) {\n        this.addRibbon();\n      }\n\n      requestAnimationFrame(this._onDraw);\n    },\n    _onResize: function _onResize(e) {\n      var screen = screenInfo(e);\n      this._width = screen.width;\n      this._height = screen.height;\n\n      if (this._canvas) {\n        this._canvas.width = this._width;\n        this._canvas.height = this._height;\n\n        if (this._context) {\n          this._context.globalAlpha = this._options.colorAlpha;\n        }\n      }\n    },\n    _onScroll: function _onScroll(e) {\n      var screen = screenInfo(e);\n      this._scroll = screen.scrolly;\n    }\n  };\n  return Factory;\n});\n\nnew Ribbons();\n\n//# sourceURL=webpack://%5Bname%5D/./src/js/bg/b4.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/js/bg/b4.js");
/******/ })()
;
});