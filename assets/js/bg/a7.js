/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["a7"] = factory();
	else
		root["a7"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/bg/a7.js":
/*!*************************!*\
  !*** ./src/js/bg/a7.js ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e16) { throw _e16; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e17) { didErr = true; err = _e17; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar rough = function () {\n  \"use strict\";\n\n  function a() {\n    return {\n      LEFT: 0,\n      RIGHT: 1,\n      INTERSECTS: 2,\n      AHEAD: 3,\n      BEHIND: 4,\n      SEPARATE: 5,\n      UNDEFINED: 6\n    };\n  }\n\n  var b = Math.tan,\n      c = Math.pow,\n      d = Math.cos,\n      e = Math.sin,\n      f = Math.PI,\n      g = Math.sqrt,\n      h = Math.max,\n      j = Math.min,\n      i = Math.abs,\n      k = Number.MAX_VALUE;\n\n  var l = /*#__PURE__*/function () {\n    function l(b, c, d, e) {\n      _classCallCheck(this, l);\n\n      this.RoughSegmentRelationConst = a(), this.px1 = b, this.py1 = c, this.px2 = d, this.py2 = e, this.xi = k, this.yi = k, this.a = e - c, this.b = b - d, this.c = d * c - b * e, this._undefined = 0 == this.a && 0 == this.b && 0 == this.c;\n    }\n\n    _createClass(l, [{\n      key: \"isUndefined\",\n      value: function isUndefined() {\n        return this._undefined;\n      }\n    }, {\n      key: \"compare\",\n      value: function compare(d) {\n        if (this.isUndefined() || d.isUndefined()) return this.RoughSegmentRelationConst.UNDEFINED;\n        var e = k,\n            f = k,\n            g = 0,\n            l = 0,\n            m = this.a,\n            n = this.b,\n            b = this.c;\n        return (1e-5 < i(n) && (e = -m / n, g = -b / n), 1e-5 < i(d.b) && (f = -d.a / d.b, l = -d.c / d.b), e == k) ? f == k ? -b / m == -d.c / d.a ? this.py1 >= j(d.py1, d.py2) && this.py1 <= h(d.py1, d.py2) ? (this.xi = this.px1, this.yi = this.py1, this.RoughSegmentRelationConst.INTERSECTS) : this.py2 >= j(d.py1, d.py2) && this.py2 <= h(d.py1, d.py2) ? (this.xi = this.px2, this.yi = this.py2, this.RoughSegmentRelationConst.INTERSECTS) : this.RoughSegmentRelationConst.SEPARATE : this.RoughSegmentRelationConst.SEPARATE : (this.xi = this.px1, this.yi = f * this.xi + l, -1e-5 > (this.py1 - this.yi) * (this.yi - this.py2) || -1e-5 > (d.py1 - this.yi) * (this.yi - d.py2) ? this.RoughSegmentRelationConst.SEPARATE : 1e-5 > i(d.a) ? -1e-5 > (d.px1 - this.xi) * (this.xi - d.px2) ? this.RoughSegmentRelationConst.SEPARATE : this.RoughSegmentRelationConst.INTERSECTS : this.RoughSegmentRelationConst.INTERSECTS) : f == k ? (this.xi = d.px1, this.yi = e * this.xi + g, -1e-5 > (d.py1 - this.yi) * (this.yi - d.py2) || -1e-5 > (this.py1 - this.yi) * (this.yi - this.py2) ? this.RoughSegmentRelationConst.SEPARATE : 1e-5 > i(m) ? -1e-5 > (this.px1 - this.xi) * (this.xi - this.px2) ? this.RoughSegmentRelationConst.SEPARATE : this.RoughSegmentRelationConst.INTERSECTS : this.RoughSegmentRelationConst.INTERSECTS) : e == f ? g == l ? this.px1 >= j(d.px1, d.px2) && this.px1 <= h(d.py1, d.py2) ? (this.xi = this.px1, this.yi = this.py1, this.RoughSegmentRelationConst.INTERSECTS) : this.px2 >= j(d.px1, d.px2) && this.px2 <= h(d.px1, d.px2) ? (this.xi = this.px2, this.yi = this.py2, this.RoughSegmentRelationConst.INTERSECTS) : this.RoughSegmentRelationConst.SEPARATE : this.RoughSegmentRelationConst.SEPARATE : (this.xi = (l - g) / (e - f), this.yi = e * this.xi + g, -1e-5 > (this.px1 - this.xi) * (this.xi - this.px2) || -1e-5 > (d.px1 - this.xi) * (this.xi - d.px2) ? this.RoughSegmentRelationConst.SEPARATE : this.RoughSegmentRelationConst.INTERSECTS);\n      }\n    }, {\n      key: \"getLength\",\n      value: function getLength() {\n        return this._getLength(this.px1, this.py1, this.px2, this.py2);\n      }\n    }, {\n      key: \"_getLength\",\n      value: function _getLength(a, b, c, d) {\n        var e = c - a,\n            f = d - b;\n        return g(e * e + f * f);\n      }\n    }]);\n\n    return l;\n  }();\n\n  var m = /*#__PURE__*/function () {\n    function m(a, b, c, d, e, f, g, h) {\n      _classCallCheck(this, m);\n\n      this.top = a, this.bottom = b, this.left = c, this.right = d, this.gap = e, this.sinAngle = f, this.tanAngle = h, 1e-4 > i(f) ? this.pos = c + e : .9999 < i(f) ? this.pos = a + e : (this.deltaX = (b - a) * i(h), this.pos = c - i(this.deltaX), this.hGap = i(e / g), this.sLeft = new l(c, b, c, a), this.sRight = new l(d, b, d, a));\n    }\n\n    _createClass(m, [{\n      key: \"getNextLine\",\n      value: function getNextLine() {\n        if (1e-4 > i(this.sinAngle)) {\n          if (this.pos < this.right) {\n            var _a = [this.pos, this.top, this.pos, this.bottom];\n            return this.pos += this.gap, _a;\n          }\n        } else if (!(.9999 < i(this.sinAngle))) {\n          var _b = this.pos - this.deltaX / 2,\n              _c = this.pos + this.deltaX / 2,\n              _d = this.bottom,\n              _e = this.top;\n\n          if (this.pos < this.right + this.deltaX) {\n            for (; _b < this.left && _c < this.left || _b > this.right && _c > this.right;) {\n              if (this.pos += this.hGap, _b = this.pos - this.deltaX / 2, _c = this.pos + this.deltaX / 2, this.pos > this.right + this.deltaX) return null;\n            }\n\n            var _f = new l(_b, _d, _c, _e);\n\n            _f.compare(this.sLeft) == a().INTERSECTS && (_b = _f.xi, _d = _f.yi), _f.compare(this.sRight) == a().INTERSECTS && (_c = _f.xi, _e = _f.yi), 0 < this.tanAngle && (_b = this.right - (_b - this.left), _c = this.right - (_c - this.left));\n            var _g = [_b, _d, _c, _e];\n            return this.pos += this.hGap, _g;\n          }\n        } else if (this.pos < this.bottom) {\n          var _a2 = [this.left, this.pos, this.right, this.pos];\n          return this.pos += this.gap, _a2;\n        }\n\n        return null;\n      }\n    }]);\n\n    return m;\n  }();\n\n  var n = /*#__PURE__*/function () {\n    function n(a, b) {\n      _classCallCheck(this, n);\n\n      this.type = a, this.text = b;\n    }\n\n    _createClass(n, [{\n      key: \"isType\",\n      value: function isType(a) {\n        return this.type === a;\n      }\n    }]);\n\n    return n;\n  }();\n\n  var o = /*#__PURE__*/function () {\n    function o(a) {\n      _classCallCheck(this, o);\n\n      this.PARAMS = {\n        A: [\"rx\", \"ry\", \"x-axis-rotation\", \"large-arc-flag\", \"sweep-flag\", \"x\", \"y\"],\n        a: [\"rx\", \"ry\", \"x-axis-rotation\", \"large-arc-flag\", \"sweep-flag\", \"x\", \"y\"],\n        C: [\"x1\", \"y1\", \"x2\", \"y2\", \"x\", \"y\"],\n        c: [\"x1\", \"y1\", \"x2\", \"y2\", \"x\", \"y\"],\n        H: [\"x\"],\n        h: [\"x\"],\n        L: [\"x\", \"y\"],\n        l: [\"x\", \"y\"],\n        M: [\"x\", \"y\"],\n        m: [\"x\", \"y\"],\n        Q: [\"x1\", \"y1\", \"x\", \"y\"],\n        q: [\"x1\", \"y1\", \"x\", \"y\"],\n        S: [\"x2\", \"y2\", \"x\", \"y\"],\n        s: [\"x2\", \"y2\", \"x\", \"y\"],\n        T: [\"x\", \"y\"],\n        t: [\"x\", \"y\"],\n        V: [\"y\"],\n        v: [\"y\"],\n        Z: [],\n        z: []\n      }, this.COMMAND = 0, this.NUMBER = 1, this.EOD = 2, this.segments = [], this.d = a || \"\", this.parseData(a), this.processPoints();\n    }\n\n    _createClass(o, [{\n      key: \"loadFromSegments\",\n      value: function loadFromSegments(a) {\n        this.segments = a, this.processPoints();\n      }\n    }, {\n      key: \"processPoints\",\n      value: function processPoints() {\n        var a = null,\n            b = [0, 0];\n\n        for (var _c2, _d2 = 0; _d2 < this.segments.length; _d2++) {\n          switch (_c2 = this.segments[_d2], _c2.key) {\n            case \"M\":\n            case \"L\":\n            case \"T\":\n              _c2.point = [_c2.data[0], _c2.data[1]];\n              break;\n\n            case \"m\":\n            case \"l\":\n            case \"t\":\n              _c2.point = [_c2.data[0] + b[0], _c2.data[1] + b[1]];\n              break;\n\n            case \"H\":\n              _c2.point = [_c2.data[0], b[1]];\n              break;\n\n            case \"h\":\n              _c2.point = [_c2.data[0] + b[0], b[1]];\n              break;\n\n            case \"V\":\n              _c2.point = [b[0], _c2.data[0]];\n              break;\n\n            case \"v\":\n              _c2.point = [b[0], _c2.data[0] + b[1]];\n              break;\n\n            case \"z\":\n            case \"Z\":\n              a && (_c2.point = [a[0], a[1]]);\n              break;\n\n            case \"C\":\n              _c2.point = [_c2.data[4], _c2.data[5]];\n              break;\n\n            case \"c\":\n              _c2.point = [_c2.data[4] + b[0], _c2.data[5] + b[1]];\n              break;\n\n            case \"S\":\n              _c2.point = [_c2.data[2], _c2.data[3]];\n              break;\n\n            case \"s\":\n              _c2.point = [_c2.data[2] + b[0], _c2.data[3] + b[1]];\n              break;\n\n            case \"Q\":\n              _c2.point = [_c2.data[2], _c2.data[3]];\n              break;\n\n            case \"q\":\n              _c2.point = [_c2.data[2] + b[0], _c2.data[3] + b[1]];\n              break;\n\n            case \"A\":\n              _c2.point = [_c2.data[5], _c2.data[6]];\n              break;\n\n            case \"a\":\n              _c2.point = [_c2.data[5] + b[0], _c2.data[6] + b[1]];\n          }\n\n          (\"m\" === _c2.key || \"M\" === _c2.key) && (a = null), _c2.point && (b = _c2.point, !a && (a = _c2.point)), (\"z\" === _c2.key || \"Z\" === _c2.key) && (a = null);\n        }\n      }\n    }, {\n      key: \"parseData\",\n      value: function parseData(a) {\n        var b = this.tokenize(a);\n        var c = 0,\n            d = b[c],\n            e = \"BOD\";\n\n        for (this.segments = []; !d.isType(this.EOD);) {\n          var _f2 = void 0;\n\n          var _g2 = [];\n          if (!(\"BOD\" == e)) d.isType(this.NUMBER) ? _f2 = this.PARAMS[e].length : (c++, _f2 = this.PARAMS[d.text].length, e = d.text);else if (\"M\" == d.text || \"m\" == d.text) c++, _f2 = this.PARAMS[d.text].length, e = d.text;else return this.parseData(\"M0,0\" + a);\n\n          if (c + _f2 < b.length) {\n            var _h = void 0,\n                _j = c;\n\n            for (; _j < c + _f2; _j++) {\n              if (_h = b[_j], _h.isType(this.NUMBER)) _g2[_g2.length] = _h.text;else return void console.error(\"Parameter type is not a number: \" + e + \",\" + _h.text);\n            }\n\n            var _i = void 0;\n\n            if (this.PARAMS[e]) _i = {\n              key: e,\n              data: _g2\n            };else return void console.error(\"Unsupported segment type: \" + e);\n            this.segments.push(_i), c += _f2, d = b[c], \"M\" == e && (e = \"L\"), \"m\" == e && (e = \"l\");\n          } else console.error(\"Path data ended before all parameters were found\");\n        }\n      }\n    }, {\n      key: \"tokenize\",\n      value: function tokenize(a) {\n        for (var b = []; \"\" != a;) {\n          if (a.match(/^([ \\t\\r\\n,]+)/)) a = a.substr(RegExp.$1.length);else if (a.match(/^([aAcChHlLmMqQsStTvVzZ])/)) b[b.length] = new n(this.COMMAND, RegExp.$1), a = a.substr(RegExp.$1.length);else if (a.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) b[b.length] = new n(this.NUMBER, parseFloat(RegExp.$1)), a = a.substr(RegExp.$1.length);else return console.error(\"Unrecognized segment command: \" + a), null;\n        }\n\n        return b[b.length] = new n(this.EOD, null), b;\n      }\n    }, {\n      key: \"closed\",\n      get: function get() {\n        if (\"undefined\" == typeof this._closed) {\n          this._closed = !1;\n\n          var _iterator = _createForOfIteratorHelper(this.segments),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _a3 = _step.value;\n              \"z\" === _a3.key.toLowerCase() && (this._closed = !0);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        return this._closed;\n      }\n    }]);\n\n    return o;\n  }();\n\n  var q = /*#__PURE__*/function () {\n    function q(a) {\n      _classCallCheck(this, q);\n\n      this.d = a, this.parsed = new o(a), this._position = [0, 0], this.bezierReflectionPoint = null, this.quadReflectionPoint = null, this._first = null;\n    }\n\n    _createClass(q, [{\n      key: \"setPosition\",\n      value: function setPosition(a, b) {\n        this._position = [a, b], this._first || (this._first = [a, b]);\n      }\n    }, {\n      key: \"segments\",\n      get: function get() {\n        return this.parsed.segments;\n      }\n    }, {\n      key: \"closed\",\n      get: function get() {\n        return this.parsed.closed;\n      }\n    }, {\n      key: \"linearPoints\",\n      get: function get() {\n        if (!this._linearPoints) {\n          var _a4 = [];\n          var _b2 = [];\n\n          var _iterator2 = _createForOfIteratorHelper(this.parsed.segments),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _c3 = _step2.value;\n\n              var _d3 = _c3.key.toLowerCase();\n\n              (\"m\" === _d3 || \"z\" === _d3) && (_b2.length && (_a4.push(_b2), _b2 = []), \"z\" === _d3) || _c3.point && _b2.push(_c3.point);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          _b2.length && (_a4.push(_b2), _b2 = []), this._linearPoints = _a4;\n        }\n\n        return this._linearPoints;\n      }\n    }, {\n      key: \"first\",\n      get: function get() {\n        return this._first;\n      },\n      set: function set(a) {\n        this._first = a;\n      }\n    }, {\n      key: \"position\",\n      get: function get() {\n        return this._position;\n      }\n    }, {\n      key: \"x\",\n      get: function get() {\n        return this._position[0];\n      }\n    }, {\n      key: \"y\",\n      get: function get() {\n        return this._position[1];\n      }\n    }]);\n\n    return q;\n  }();\n\n  var p = /*#__PURE__*/function () {\n    function p(a, b, c, h, j, k) {\n      _classCallCheck(this, p);\n\n      var l = f / 180;\n      if (this._segIndex = 0, this._numSegs = 0, a[0] == b[0] && a[1] == b[1]) return;\n      this._rx = i(c[0]), this._ry = i(c[1]), this._sinPhi = e(h * l), this._cosPhi = d(h * l);\n      var m;\n\n      var n = this._cosPhi * (a[0] - b[0]) / 2 + this._sinPhi * (a[1] - b[1]) / 2,\n          o = -this._sinPhi * (a[0] - b[0]) / 2 + this._cosPhi * (a[1] - b[1]) / 2,\n          _p = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * o * o - this._ry * this._ry * n * n;\n\n      if (0 > _p) {\n        var _a5 = g(1 - _p / (this._rx * this._rx * this._ry * this._ry));\n\n        this._rx = _a5, this._ry = _a5, m = 0;\n      } else m = (j == k ? -1 : 1) * g(_p / (this._rx * this._rx * o * o + this._ry * this._ry * n * n));\n\n      var q = m * this._rx * o / this._ry,\n          r = -m * this._ry * n / this._rx;\n      this._C = [0, 0], this._C[0] = this._cosPhi * q - this._sinPhi * r + (a[0] + b[0]) / 2, this._C[1] = this._sinPhi * q + this._cosPhi * r + (a[1] + b[1]) / 2, this._theta = this.calculateVectorAngle(1, 0, (n - q) / this._rx, (o - r) / this._ry);\n      var s = this.calculateVectorAngle((n - q) / this._rx, (o - r) / this._ry, (-n - q) / this._rx, (-o - r) / this._ry);\n      !k && 0 < s ? s -= 2 * f : k && 0 > s && (s += 2 * f), this._numSegs = Math.ceil(i(s / (f / 2))), this._delta = s / this._numSegs, this._T = 8 / 3 * e(this._delta / 4) * e(this._delta / 4) / e(this._delta / 2), this._from = a;\n    }\n\n    _createClass(p, [{\n      key: \"getNextSegment\",\n      value: function getNextSegment() {\n        var a, b, c;\n        if (this._segIndex == this._numSegs) return null;\n        var f = d(this._theta),\n            g = e(this._theta),\n            h = this._theta + this._delta,\n            i = d(h),\n            j = e(h);\n        return c = [this._cosPhi * this._rx * i - this._sinPhi * this._ry * j + this._C[0], this._sinPhi * this._rx * i + this._cosPhi * this._ry * j + this._C[1]], a = [this._from[0] + this._T * (-this._cosPhi * this._rx * g - this._sinPhi * this._ry * f), this._from[1] + this._T * (-this._sinPhi * this._rx * g + this._cosPhi * this._ry * f)], b = [c[0] + this._T * (this._cosPhi * this._rx * j + this._sinPhi * this._ry * i), c[1] + this._T * (this._sinPhi * this._rx * j - this._cosPhi * this._ry * i)], this._theta = h, this._from = [c[0], c[1]], this._segIndex++, {\n          cp1: a,\n          cp2: b,\n          to: c\n        };\n      }\n    }, {\n      key: \"calculateVectorAngle\",\n      value: function calculateVectorAngle(a, b, c, d) {\n        var e = Math.atan2;\n        var g = e(b, a),\n            h = e(d, c);\n        return h >= g ? h - g : 2 * f - (g - h);\n      }\n    }]);\n\n    return p;\n  }();\n\n  var r = /*#__PURE__*/function () {\n    function r(a, b) {\n      _classCallCheck(this, r);\n\n      this.sets = a, this.closed = b;\n    }\n\n    _createClass(r, [{\n      key: \"fit\",\n      value: function fit(a) {\n        var b = [];\n\n        var _iterator3 = _createForOfIteratorHelper(this.sets),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _c4 = _step3.value;\n\n            var _d5 = _c4.length,\n                _e2 = Math.floor(a * _d5);\n\n            if (5 > _e2) {\n              if (5 >= _d5) continue;\n              _e2 = 5;\n            }\n\n            b.push(this.reduce(_c4, _e2));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var c = \"\";\n\n        for (var _i2 = 0, _b3 = b; _i2 < _b3.length; _i2++) {\n          var _d4 = _b3[_i2];\n\n          for (var _a6, _b4 = 0; _b4 < _d4.length; _b4++) {\n            _a6 = _d4[_b4], c += 0 === _b4 ? \"M\" + _a6[0] + \",\" + _a6[1] : \"L\" + _a6[0] + \",\" + _a6[1];\n          }\n\n          this.closed && (c += \"z \");\n        }\n\n        return c;\n      }\n    }, {\n      key: \"distance\",\n      value: function distance(a, b) {\n        return g(c(a[0] - b[0], 2) + c(a[1] - b[1], 2));\n      }\n    }, {\n      key: \"reduce\",\n      value: function reduce(a, b) {\n        if (a.length <= b) return a;\n        var d = a.slice(0);\n\n        for (; d.length > b;) {\n          var _e3 = -1,\n              _f3 = -1;\n\n          for (var _h2 = 1; _h2 < d.length - 1; _h2++) {\n            var _i3 = this.distance(d[_h2 - 1], d[_h2]),\n                _a7 = this.distance(d[_h2], d[_h2 + 1]),\n                _b5 = this.distance(d[_h2 - 1], d[_h2 + 1]),\n                _c5 = (_i3 + _a7 + _b5) / 2,\n                _j2 = g(_c5 * (_c5 - _i3) * (_c5 - _a7) * (_c5 - _b5));\n\n            (0 > _e3 || _j2 < _e3) && (_e3 = _j2, _f3 = _h2);\n          }\n\n          if (0 < _f3) d.splice(_f3, 1);else break;\n        }\n\n        return d;\n      }\n    }]);\n\n    return r;\n  }();\n\n  var s = /*#__PURE__*/function () {\n    function s() {\n      _classCallCheck(this, s);\n    }\n\n    _createClass(s, [{\n      key: \"line\",\n      value: function line(a, b, c, d, e) {\n        var f = this._doubleLine(a, b, c, d, e);\n\n        return {\n          type: \"path\",\n          ops: f\n        };\n      }\n    }, {\n      key: \"linearPath\",\n      value: function linearPath(a, b, c) {\n        var d = (a || []).length;\n\n        if (2 < d) {\n          var _e4 = [];\n\n          for (var _b6 = 0; _b6 < d - 1; _b6++) {\n            _e4 = _e4.concat(this._doubleLine(a[_b6][0], a[_b6][1], a[_b6 + 1][0], a[_b6 + 1][1], c));\n          }\n\n          return b && (_e4 = _e4.concat(this._doubleLine(a[d - 1][0], a[d - 1][1], a[0][0], a[0][1], c))), {\n            type: \"path\",\n            ops: _e4\n          };\n        }\n\n        return 2 === d ? this.line(a[0][0], a[0][1], a[1][0], a[1][1], c) : void 0;\n      }\n    }, {\n      key: \"polygon\",\n      value: function polygon(a, b) {\n        return this.linearPath(a, !0, b);\n      }\n    }, {\n      key: \"rectangle\",\n      value: function rectangle(a, b, c, d, e) {\n        return this.polygon([[a, b], [a + c, b], [a + c, b + d], [a, b + d]], e);\n      }\n    }, {\n      key: \"curve\",\n      value: function curve(a, b) {\n        var c = this._curveWithOffset(a, 1 * (1 + .2 * b.roughness), b),\n            d = this._curveWithOffset(a, 1.5 * (1 + .22 * b.roughness), b);\n\n        return {\n          type: \"path\",\n          ops: c.concat(d)\n        };\n      }\n    }, {\n      key: \"ellipse\",\n      value: function ellipse(a, b, c, d, e) {\n        var g = 2 * f / e.curveStepCount;\n        var h = i(c / 2),\n            j = i(d / 2);\n        h += this._getOffset(.05 * -h, .05 * h, e), j += this._getOffset(.05 * -j, .05 * j, e);\n\n        var k = this._ellipse(g, a, b, h, j, 1, g * this._getOffset(.1, this._getOffset(.4, 1, e), e), e),\n            l = this._ellipse(g, a, b, h, j, 1.5, 0, e);\n\n        return {\n          type: \"path\",\n          ops: k.concat(l)\n        };\n      }\n    }, {\n      key: \"arc\",\n      value: function arc(a, b, c, g, h, k, l, m, n) {\n        var o = a,\n            p = b,\n            q = i(c / 2),\n            r = i(g / 2);\n        q += this._getOffset(.01 * -q, .01 * q, n), r += this._getOffset(.01 * -r, .01 * r, n);\n        var s = h,\n            t = k;\n\n        for (; 0 > s;) {\n          s += 2 * f, t += 2 * f;\n        }\n\n        t - s > 2 * f && (s = 0, t = 2 * f);\n\n        var u = 2 * f / n.curveStepCount,\n            v = j(u / 2, (t - s) / 2),\n            w = this._arc(v, o, p, q, r, s, t, 1, n),\n            x = this._arc(v, o, p, q, r, s, t, 1.5, n),\n            y = w.concat(x);\n\n        return l && (m ? (y = y.concat(this._doubleLine(o, p, o + q * d(s), p + r * e(s), n)), y = y.concat(this._doubleLine(o, p, o + q * d(t), p + r * e(t), n))) : (y.push({\n          op: \"lineTo\",\n          data: [o, p]\n        }), y.push({\n          op: \"lineTo\",\n          data: [o + q * d(s), p + r * e(s)]\n        }))), {\n          type: \"path\",\n          ops: y\n        };\n      }\n    }, {\n      key: \"hachureFillArc\",\n      value: function hachureFillArc(a, b, c, g, h, j, k) {\n        var l = a,\n            m = b,\n            n = i(c / 2),\n            o = i(g / 2);\n        n += this._getOffset(.01 * -n, .01 * n, k), o += this._getOffset(.01 * -o, .01 * o, k);\n        var p = h,\n            q = j;\n\n        for (; 0 > p;) {\n          p += 2 * f, q += 2 * f;\n        }\n\n        q - p > 2 * f && (p = 0, q = 2 * f);\n        var r = (q - p) / k.curveStepCount,\n            s = [],\n            t = [];\n\n        for (var _f4 = p; _f4 <= q; _f4 += r) {\n          s.push(l + n * d(_f4)), t.push(m + o * e(_f4));\n        }\n\n        return s.push(l + n * d(q)), t.push(m + o * e(q)), s.push(l), t.push(m), this.hachureFillShape(s, t, k);\n      }\n    }, {\n      key: \"solidFillShape\",\n      value: function solidFillShape(a, b, c) {\n        var d = [];\n\n        if (a && b && a.length && b.length && a.length === b.length) {\n          var _f5 = c.maxRandomnessOffset || 0;\n\n          var _g3 = a.length;\n\n          if (2 < _g3) {\n            d.push({\n              op: \"move\",\n              data: [a[0] + this._getOffset(-_f5, _f5, c), b[0] + this._getOffset(-_f5, _f5, c)]\n            });\n\n            for (var _e5 = 1; _e5 < _g3; _e5++) {\n              d.push({\n                op: \"lineTo\",\n                data: [a[_e5] + this._getOffset(-_f5, _f5, c), b[_e5] + this._getOffset(-_f5, _f5, c)]\n              });\n            }\n          }\n        }\n\n        return {\n          type: \"fillPath\",\n          ops: d\n        };\n      }\n    }, {\n      key: \"hachureFillShape\",\n      value: function hachureFillShape(a, c, g) {\n        var k = [];\n\n        if (a && c && a.length && c.length) {\n          var _l = a[0],\n              _n = a[0],\n              _o = c[0],\n              _p2 = c[0];\n\n          for (var _b7 = 1; _b7 < a.length; _b7++) {\n            _l = j(_l, a[_b7]), _n = h(_n, a[_b7]), _o = j(_o, c[_b7]), _p2 = h(_p2, c[_b7]);\n          }\n\n          var _i4 = g.hachureAngle;\n          var _q = g.hachureGap;\n          0 > _q && (_q = 4 * g.strokeWidth), _q = h(_q, .1);\n\n          var _r = _i4 % 180 * (f / 180),\n              _s = d(_r),\n              _t = e(_r),\n              _u = b(_r),\n              _v = new m(_o - 1, _p2 + 1, _l - 1, _n + 1, _q, _t, _s, _u);\n\n          for (var _b8; null != (_b8 = _v.getNextLine());) {\n            var _d6 = this._getIntersectingLines(_b8, a, c);\n\n            for (var _a8 = 0; _a8 < _d6.length; _a8++) {\n              if (_a8 < _d6.length - 1) {\n                var _b9 = _d6[_a8],\n                    _c6 = _d6[_a8 + 1];\n                k = k.concat(this._doubleLine(_b9[0], _b9[1], _c6[0], _c6[1], g));\n              }\n            }\n          }\n        }\n\n        return {\n          type: \"fillSketch\",\n          ops: k\n        };\n      }\n    }, {\n      key: \"hachureFillEllipse\",\n      value: function hachureFillEllipse(a, c, d, e, h) {\n        var j = [],\n            k = i(d / 2),\n            l = i(e / 2);\n        k += this._getOffset(.05 * -k, .05 * k, h), l += this._getOffset(.05 * -l, .05 * l, h);\n        var m = h.hachureAngle,\n            n = h.hachureGap;\n        0 >= n && (n = 4 * h.strokeWidth);\n        var o = h.fillWeight;\n        0 > o && (o = h.strokeWidth / 2);\n        var p = b(m % 180 * (f / 180)),\n            q = l / k,\n            r = g(q * p * q * p + 1),\n            s = q * p / r,\n            t = 1 / r,\n            u = n / (k * l / g(l * t * (l * t) + k * s * (k * s)) / k),\n            v = g(k * k - (a - k + u) * (a - k + u));\n\n        for (var _w = a - k + u; _w < a + k; _w += u) {\n          v = g(k * k - (a - _w) * (a - _w));\n\n          var _b10 = this._affine(_w, c - v, a, c, s, t, q),\n              _d7 = this._affine(_w, c + v, a, c, s, t, q);\n\n          j = j.concat(this._doubleLine(_b10[0], _b10[1], _d7[0], _d7[1], h));\n        }\n\n        return {\n          type: \"fillSketch\",\n          ops: j\n        };\n      }\n    }, {\n      key: \"svgPath\",\n      value: function svgPath(a, b) {\n        a = (a || \"\").replace(/\\n/g, \" \").replace(/(-)/g, \" -\").replace(/(-\\s)/g, \"-\").replace(\"/(ss)/g\", \" \");\n        var c = new q(a);\n\n        if (b.simplification) {\n          var _a9 = new r(c.linearPoints, c.closed),\n              _e6 = _a9.fit(b.simplification);\n\n          c = new q(_e6);\n        }\n\n        var d = [],\n            e = c.segments || [];\n\n        for (var _f6 = 0; _f6 < e.length; _f6++) {\n          var _a10 = e[_f6],\n              _g4 = 0 < _f6 ? e[_f6 - 1] : null,\n              _h3 = this._processSegment(c, _a10, _g4, b);\n\n          _h3 && _h3.length && (d = d.concat(_h3));\n        }\n\n        return {\n          type: \"path\",\n          ops: d\n        };\n      }\n    }, {\n      key: \"_bezierTo\",\n      value: function _bezierTo(a, b, c, d, e, g, h, j) {\n        var k = [],\n            l = [j.maxRandomnessOffset || 1, (j.maxRandomnessOffset || 1) + .5],\n            m = null;\n\n        for (var _f7 = 0; 2 > _f7; _f7++) {\n          0 === _f7 ? k.push({\n            op: \"move\",\n            data: [h.x, h.y]\n          }) : k.push({\n            op: \"move\",\n            data: [h.x + this._getOffset(-l[0], l[0], j), h.y + this._getOffset(-l[0], l[0], j)]\n          }), m = [e + this._getOffset(-l[_f7], l[_f7], j), g + this._getOffset(-l[_f7], l[_f7], j)], k.push({\n            op: \"bcurveTo\",\n            data: [a + this._getOffset(-l[_f7], l[_f7], j), b + this._getOffset(-l[_f7], l[_f7], j), c + this._getOffset(-l[_f7], l[_f7], j), d + this._getOffset(-l[_f7], l[_f7], j), m[0], m[1]]\n          });\n        }\n\n        return h.setPosition(m[0], m[1]), k;\n      }\n    }, {\n      key: \"_processSegment\",\n      value: function _processSegment(a, b, c, d) {\n        var e = [];\n\n        switch (b.key) {\n          case \"M\":\n          case \"m\":\n            {\n              var _c7 = \"m\" === b.key;\n\n              if (2 <= b.data.length) {\n                var _f8 = +b.data[0],\n                    _g5 = +b.data[1];\n\n                _c7 && (_f8 += a.x, _g5 += a.y);\n\n                var _h4 = 1 * (d.maxRandomnessOffset || 0);\n\n                _f8 += this._getOffset(-_h4, _h4, d), _g5 += this._getOffset(-_h4, _h4, d), a.setPosition(_f8, _g5), e.push({\n                  op: \"move\",\n                  data: [_f8, _g5]\n                });\n              }\n\n              break;\n            }\n\n          case \"L\":\n          case \"l\":\n            {\n              var _c8 = \"l\" === b.key;\n\n              if (2 <= b.data.length) {\n                var _f9 = +b.data[0],\n                    _g6 = +b.data[1];\n\n                _c8 && (_f9 += a.x, _g6 += a.y), e = e.concat(this._doubleLine(a.x, a.y, _f9, _g6, d)), a.setPosition(_f9, _g6);\n              }\n\n              break;\n            }\n\n          case \"H\":\n          case \"h\":\n            {\n              var _c9 = \"h\" === b.key;\n\n              if (b.data.length) {\n                var _f10 = +b.data[0];\n\n                _c9 && (_f10 += a.x), e = e.concat(this._doubleLine(a.x, a.y, _f10, a.y, d)), a.setPosition(_f10, a.y);\n              }\n\n              break;\n            }\n\n          case \"V\":\n          case \"v\":\n            {\n              var _c10 = \"v\" === b.key;\n\n              if (b.data.length) {\n                var _f11 = +b.data[0];\n\n                _c10 && (_f11 += a.y), e = e.concat(this._doubleLine(a.x, a.y, a.x, _f11, d)), a.setPosition(a.x, _f11);\n              }\n\n              break;\n            }\n\n          case \"Z\":\n          case \"z\":\n            {\n              a.first && (e = e.concat(this._doubleLine(a.x, a.y, a.first[0], a.first[1], d)), a.setPosition(a.first[0], a.first[1]), a.first = null);\n              break;\n            }\n\n          case \"C\":\n          case \"c\":\n            {\n              var _c11 = \"c\" === b.key;\n\n              if (6 <= b.data.length) {\n                var _f12 = +b.data[0],\n                    _g7 = +b.data[1],\n                    _h5 = +b.data[2],\n                    _i5 = +b.data[3],\n                    _j3 = +b.data[4],\n                    _k = +b.data[5];\n\n                _c11 && (_f12 += a.x, _h5 += a.x, _j3 += a.x, _g7 += a.y, _i5 += a.y, _k += a.y);\n\n                var _l2 = this._bezierTo(_f12, _g7, _h5, _i5, _j3, _k, a, d);\n\n                e = e.concat(_l2), a.bezierReflectionPoint = [_j3 + (_j3 - _h5), _k + (_k - _i5)];\n              }\n\n              break;\n            }\n\n          case \"S\":\n          case \"s\":\n            {\n              var _f13 = \"s\" === b.key;\n\n              if (4 <= b.data.length) {\n                var _h6 = +b.data[0],\n                    _i6 = +b.data[1],\n                    _j4 = +b.data[2],\n                    _k2 = +b.data[3];\n\n                _f13 && (_h6 += a.x, _j4 += a.x, _i6 += a.y, _k2 += a.y);\n\n                var _l3 = _h6,\n                    _m = _i6,\n                    _n2 = c ? c.key : \"\";\n\n                var g = null;\n                (\"c\" == _n2 || \"C\" == _n2 || \"s\" == _n2 || \"S\" == _n2) && (g = a.bezierReflectionPoint), g && (_l3 = g[0], _m = g[1]);\n\n                var _o2 = this._bezierTo(_l3, _m, _h6, _i6, _j4, _k2, a, d);\n\n                e = e.concat(_o2), a.bezierReflectionPoint = [_j4 + (_j4 - _h6), _k2 + (_k2 - _i6)];\n              }\n\n              break;\n            }\n\n          case \"Q\":\n          case \"q\":\n            {\n              var _c12 = \"q\" === b.key;\n\n              if (4 <= b.data.length) {\n                var _g8 = +b.data[0],\n                    _h7 = +b.data[1],\n                    _i7 = +b.data[2],\n                    _j5 = +b.data[3];\n\n                _c12 && (_g8 += a.x, _i7 += a.x, _h7 += a.y, _j5 += a.y);\n\n                var _k3 = 1 * (1 + .2 * d.roughness),\n                    _l4 = 1.5 * (1 + .22 * d.roughness);\n\n                e.push({\n                  op: \"move\",\n                  data: [a.x + this._getOffset(-_k3, _k3, d), a.y + this._getOffset(-_k3, _k3, d)]\n                });\n                var _m2 = [_i7 + this._getOffset(-_k3, _k3, d), _j5 + this._getOffset(-_k3, _k3, d)];\n                e.push({\n                  op: \"qcurveTo\",\n                  data: [_g8 + this._getOffset(-_k3, _k3, d), _h7 + this._getOffset(-_k3, _k3, d), _m2[0], _m2[1]]\n                }), e.push({\n                  op: \"move\",\n                  data: [a.x + this._getOffset(-_l4, _l4, d), a.y + this._getOffset(-_l4, _l4, d)]\n                }), _m2 = [_i7 + this._getOffset(-_l4, _l4, d), _j5 + this._getOffset(-_l4, _l4, d)], e.push({\n                  op: \"qcurveTo\",\n                  data: [_g8 + this._getOffset(-_l4, _l4, d), _h7 + this._getOffset(-_l4, _l4, d), _m2[0], _m2[1]]\n                }), a.setPosition(_m2[0], _m2[1]), a.quadReflectionPoint = [_i7 + (_i7 - _g8), _j5 + (_j5 - _h7)];\n              }\n\n              break;\n            }\n\n          case \"T\":\n          case \"t\":\n            {\n              var _h8 = \"t\" === b.key;\n\n              if (2 <= b.data.length) {\n                var _i8 = +b.data[0],\n                    _j6 = +b.data[1];\n\n                _h8 && (_i8 += a.x, _j6 += a.y);\n\n                var _k4 = _i8,\n                    _l5 = _j6,\n                    _m3 = c ? c.key : \"\";\n\n                var g = null;\n                (\"q\" == _m3 || \"Q\" == _m3 || \"t\" == _m3 || \"T\" == _m3) && (g = a.quadReflectionPoint), g && (_k4 = g[0], _l5 = g[1]);\n\n                var _n3 = 1 * (1 + .2 * d.roughness),\n                    _o3 = 1.5 * (1 + .22 * d.roughness);\n\n                e.push({\n                  op: \"move\",\n                  data: [a.x + this._getOffset(-_n3, _n3, d), a.y + this._getOffset(-_n3, _n3, d)]\n                });\n                var _p3 = [_i8 + this._getOffset(-_n3, _n3, d), _j6 + this._getOffset(-_n3, _n3, d)];\n                e.push({\n                  op: \"qcurveTo\",\n                  data: [_k4 + this._getOffset(-_n3, _n3, d), _l5 + this._getOffset(-_n3, _n3, d), _p3[0], _p3[1]]\n                }), e.push({\n                  op: \"move\",\n                  data: [a.x + this._getOffset(-_o3, _o3, d), a.y + this._getOffset(-_o3, _o3, d)]\n                }), _p3 = [_i8 + this._getOffset(-_o3, _o3, d), _j6 + this._getOffset(-_o3, _o3, d)], e.push({\n                  op: \"qcurveTo\",\n                  data: [_k4 + this._getOffset(-_o3, _o3, d), _l5 + this._getOffset(-_o3, _o3, d), _p3[0], _p3[1]]\n                }), a.setPosition(_p3[0], _p3[1]), a.quadReflectionPoint = [_i8 + (_i8 - _k4), _j6 + (_j6 - _l5)];\n              }\n\n              break;\n            }\n\n          case \"A\":\n          case \"a\":\n            {\n              var _c13 = \"a\" === b.key;\n\n              if (7 <= b.data.length) {\n                var _f14 = +b.data[0],\n                    _g9 = +b.data[1],\n                    _h9 = +b.data[2],\n                    _i9 = +b.data[3],\n                    _j7 = +b.data[4],\n                    _k5 = +b.data[5],\n                    _l6 = +b.data[6];\n\n                if (_c13 && (_k5 += a.x, _l6 += a.y), _k5 == a.x && _l6 == a.y) break;\n                if (0 == _f14 || 0 == _g9) e = e.concat(this._doubleLine(a.x, a.y, _k5, _l6, d)), a.setPosition(_k5, _l6);else {\n                  d.maxRandomnessOffset || 0;\n\n                  for (var _b11 = 0; 1 > _b11; _b11++) {\n                    var _b12 = new p([a.x, a.y], [_k5, _l6], [_f14, _g9], _h9, !!_i9, !!_j7),\n                        _c14 = _b12.getNextSegment();\n\n                    for (; _c14;) {\n                      var _f15 = this._bezierTo(_c14.cp1[0], _c14.cp1[1], _c14.cp2[0], _c14.cp2[1], _c14.to[0], _c14.to[1], a, d);\n\n                      e = e.concat(_f15), _c14 = _b12.getNextSegment();\n                    }\n                  }\n                }\n              }\n\n              break;\n            }\n\n          default:\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset(a, b, c) {\n        return c.roughness * (Math.random() * (b - a) + a);\n      }\n    }, {\n      key: \"_affine\",\n      value: function _affine(a, b, c, d, e, f, g) {\n        return [-c * f - d * e + c + f * a + e * b, g * (c * e - d * f) + d + -g * e * a + g * f * b];\n      }\n    }, {\n      key: \"_doubleLine\",\n      value: function _doubleLine(a, b, c, d, e) {\n        var f = this._line(a, b, c, d, e, !0, !1),\n            g = this._line(a, b, c, d, e, !0, !0);\n\n        return f.concat(g);\n      }\n    }, {\n      key: \"_line\",\n      value: function _line(a, b, d, e, f, h, i) {\n        var j = c(a - d, 2) + c(b - e, 2);\n        var k = f.maxRandomnessOffset || 0;\n        100 * (k * k) > j && (k = g(j) / 10);\n        var l = k / 2,\n            m = .2 + .2 * Math.random();\n        var n = f.bowing * f.maxRandomnessOffset * (e - b) / 200,\n            o = f.bowing * f.maxRandomnessOffset * (a - d) / 200;\n        n = this._getOffset(-n, n, f), o = this._getOffset(-o, o, f);\n        var p = [];\n        return h && (i ? p.push({\n          op: \"move\",\n          data: [a + this._getOffset(-l, l, f), b + this._getOffset(-l, l, f)]\n        }) : p.push({\n          op: \"move\",\n          data: [a + this._getOffset(-k, k, f), b + this._getOffset(-k, k, f)]\n        })), i ? p.push({\n          op: \"bcurveTo\",\n          data: [n + a + (d - a) * m + this._getOffset(-l, l, f), o + b + (e - b) * m + this._getOffset(-l, l, f), n + a + 2 * (d - a) * m + this._getOffset(-l, l, f), o + b + 2 * (e - b) * m + this._getOffset(-l, l, f), d + this._getOffset(-l, l, f), e + this._getOffset(-l, l, f)]\n        }) : p.push({\n          op: \"bcurveTo\",\n          data: [n + a + (d - a) * m + this._getOffset(-k, k, f), o + b + (e - b) * m + this._getOffset(-k, k, f), n + a + 2 * (d - a) * m + this._getOffset(-k, k, f), o + b + 2 * (e - b) * m + this._getOffset(-k, k, f), d + this._getOffset(-k, k, f), e + this._getOffset(-k, k, f)]\n        }), p;\n      }\n    }, {\n      key: \"_curve\",\n      value: function _curve(a, c, d) {\n        var e = a.length;\n        var f = [];\n\n        if (3 < e) {\n          var _g10 = [],\n              _b13 = 1 - d.curveTightness;\n\n          f.push({\n            op: \"move\",\n            data: [a[1][0], a[1][1]]\n          });\n\n          for (var _c15 = 1; _c15 + 2 < e; _c15++) {\n            var _d8 = a[_c15];\n            _g10[0] = [_d8[0], _d8[1]], _g10[1] = [_d8[0] + (_b13 * a[_c15 + 1][0] - _b13 * a[_c15 - 1][0]) / 6, _d8[1] + (_b13 * a[_c15 + 1][1] - _b13 * a[_c15 - 1][1]) / 6], _g10[2] = [a[_c15 + 1][0] + (_b13 * a[_c15][0] - _b13 * a[_c15 + 2][0]) / 6, a[_c15 + 1][1] + (_b13 * a[_c15][1] - _b13 * a[_c15 + 2][1]) / 6], _g10[3] = [a[_c15 + 1][0], a[_c15 + 1][1]], f.push({\n              op: \"bcurveTo\",\n              data: [_g10[1][0], _g10[1][1], _g10[2][0], _g10[2][1], _g10[3][0], _g10[3][1]]\n            });\n          }\n\n          if (c && 2 === c.length) {\n            var _a11 = d.maxRandomnessOffset;\n            f.push({\n              ops: \"lineTo\",\n              data: [c[0] + this._getOffset(-_a11, _a11, d), c[1] + +this._getOffset(-_a11, _a11, d)]\n            });\n          }\n        } else 3 === e ? (f.push({\n          op: \"move\",\n          data: [a[1][0], a[1][1]]\n        }), f.push({\n          op: \"bcurveTo\",\n          data: [a[1][0], a[1][1], a[2][0], a[2][1], a[2][0], a[2][1]]\n        })) : 2 === e && (f = f.concat(this._doubleLine(a[0][0], a[0][1], a[1][0], a[1][1], d)));\n\n        return f;\n      }\n    }, {\n      key: \"_ellipse\",\n      value: function _ellipse(a, b, c, g, h, i, j, k) {\n        var l = this._getOffset(-.5, .5, k) - f / 2,\n            m = [];\n        m.push([this._getOffset(-i, i, k) + b + .9 * g * d(l - a), this._getOffset(-i, i, k) + c + .9 * h * e(l - a)]);\n\n        for (var _n4 = l; _n4 < 2 * f + l - .01; _n4 += a) {\n          m.push([this._getOffset(-i, i, k) + b + g * d(_n4), this._getOffset(-i, i, k) + c + h * e(_n4)]);\n        }\n\n        return m.push([this._getOffset(-i, i, k) + b + g * d(l + 2 * f + .5 * j), this._getOffset(-i, i, k) + c + h * e(l + 2 * f + .5 * j)]), m.push([this._getOffset(-i, i, k) + b + .98 * g * d(l + j), this._getOffset(-i, i, k) + c + .98 * h * e(l + j)]), m.push([this._getOffset(-i, i, k) + b + .9 * g * d(l + .5 * j), this._getOffset(-i, i, k) + c + .9 * h * e(l + .5 * j)]), this._curve(m, null, k);\n      }\n    }, {\n      key: \"_curveWithOffset\",\n      value: function _curveWithOffset(a, b, c) {\n        var d = [[a[0][0] + this._getOffset(-b, b, c), a[0][1] + this._getOffset(-b, b, c)], [a[0][0] + this._getOffset(-b, b, c), a[0][1] + this._getOffset(-b, b, c)]];\n\n        for (var _e7 = 1; _e7 < a.length; _e7++) {\n          d.push([a[_e7][0] + this._getOffset(-b, b, c), a[_e7][1] + this._getOffset(-b, b, c)]), _e7 === a.length - 1 && d.push([a[_e7][0] + this._getOffset(-b, b, c), a[_e7][1] + this._getOffset(-b, b, c)]);\n        }\n\n        return this._curve(d, null, c);\n      }\n    }, {\n      key: \"_arc\",\n      value: function _arc(a, b, c, f, g, h, i, j, k) {\n        var l = h + this._getOffset(-.1, .1, k),\n            m = [];\n\n        m.push([this._getOffset(-j, j, k) + b + .9 * f * d(l - a), this._getOffset(-j, j, k) + c + .9 * g * e(l - a)]);\n\n        for (var _n5 = l; _n5 <= i; _n5 += a) {\n          m.push([this._getOffset(-j, j, k) + b + f * d(_n5), this._getOffset(-j, j, k) + c + g * e(_n5)]);\n        }\n\n        return m.push([b + f * d(i), c + g * e(i)]), m.push([b + f * d(i), c + g * e(i)]), this._curve(m, null, k);\n      }\n    }, {\n      key: \"_getIntersectingLines\",\n      value: function _getIntersectingLines(b, c, d) {\n        var e = [];\n        var f = new l(b[0], b[1], b[2], b[3]);\n        var g = 0;\n\n        for (; g < c.length; g++) {\n          var _b14 = new l(c[g], d[g], c[(g + 1) % c.length], d[(g + 1) % c.length]);\n\n          f.compare(_b14) == a().INTERSECTS && e.push([f.xi, f.yi]);\n        }\n\n        return e;\n      }\n    }]);\n\n    return s;\n  }();\n\n  self._roughScript = self.document && self.document.currentScript && self.document.currentScript.src;\n\n  var t = /*#__PURE__*/function () {\n    function t(a, b) {\n      _classCallCheck(this, t);\n\n      this.config = a || {}, this.canvas = b, this.defaultOptions = {\n        maxRandomnessOffset: 2,\n        roughness: 1,\n        bowing: 1,\n        stroke: \"#000\",\n        strokeWidth: 1,\n        curveTightness: 0,\n        curveStepCount: 9,\n        fill: null,\n        fillStyle: \"hachure\",\n        fillWeight: -1,\n        hachureAngle: -41,\n        hachureGap: -1\n      }, this.config.options && (this.defaultOptions = this._options(this.config.options));\n    }\n\n    _createClass(t, [{\n      key: \"_options\",\n      value: function _options(a) {\n        return a ? Object.assign({}, this.defaultOptions, a) : this.defaultOptions;\n      }\n    }, {\n      key: \"_drawable\",\n      value: function _drawable(a, b, c) {\n        return {\n          shape: a,\n          sets: b || [],\n          options: c || this.defaultOptions\n        };\n      }\n    }, {\n      key: \"line\",\n      value: function line(a, b, c, d, e) {\n        var f = this._options(e);\n\n        return this._drawable(\"line\", [this.lib.line(a, b, c, d, f)], f);\n      }\n    }, {\n      key: \"rectangle\",\n      value: function rectangle(a, b, c, d, e) {\n        var f = this._options(e),\n            g = [];\n\n        if (f.fill) {\n          var _e8 = [a, a + c, a + c, a],\n              _h10 = [b, b, b + d, b + d];\n          \"solid\" === f.fillStyle ? g.push(this.lib.solidFillShape(_e8, _h10, f)) : g.push(this.lib.hachureFillShape(_e8, _h10, f));\n        }\n\n        return g.push(this.lib.rectangle(a, b, c, d, f)), this._drawable(\"rectangle\", g, f);\n      }\n    }, {\n      key: \"ellipse\",\n      value: function ellipse(a, b, c, d, e) {\n        var f = this._options(e),\n            g = [];\n\n        if (f.fill) if (\"solid\" === f.fillStyle) {\n          var _e9 = this.lib.ellipse(a, b, c, d, f);\n\n          _e9.type = \"fillPath\", g.push(_e9);\n        } else g.push(this.lib.hachureFillEllipse(a, b, c, d, f));\n        return g.push(this.lib.ellipse(a, b, c, d, f)), this._drawable(\"ellipse\", g, f);\n      }\n    }, {\n      key: \"circle\",\n      value: function circle(a, b, c, d) {\n        var e = this.ellipse(a, b, c, c, d);\n        return e.shape = \"circle\", e;\n      }\n    }, {\n      key: \"linearPath\",\n      value: function linearPath(a, b) {\n        var c = this._options(b);\n\n        return this._drawable(\"linearPath\", [this.lib.linearPath(a, !1, c)], c);\n      }\n    }, {\n      key: \"polygon\",\n      value: function polygon(a, b) {\n        var c = this._options(b),\n            d = [];\n\n        if (c.fill) {\n          var _b15 = [],\n              _e10 = [];\n\n          var _iterator4 = _createForOfIteratorHelper(a),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _c16 = _step4.value;\n              _b15.push(_c16[0]), _e10.push(_c16[1]);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          \"solid\" === c.fillStyle ? d.push(this.lib.solidFillShape(_b15, _e10, c)) : d.push(this.lib.hachureFillShape(_b15, _e10, c));\n        }\n\n        return d.push(this.lib.linearPath(a, !0, c)), this._drawable(\"polygon\", d, c);\n      }\n    }, {\n      key: \"arc\",\n      value: function arc(a, b, c, d, e, f, g, h) {\n        var i = this._options(h),\n            j = [];\n\n        if (g && i.fill) if (\"solid\" === i.fillStyle) {\n          var _g11 = this.lib.arc(a, b, c, d, e, f, !0, !1, i);\n\n          _g11.type = \"fillPath\", j.push(_g11);\n        } else j.push(this.lib.hachureFillArc(a, b, c, d, e, f, i));\n        return j.push(this.lib.arc(a, b, c, d, e, f, g, !0, i)), this._drawable(\"arc\", j, i);\n      }\n    }, {\n      key: \"curve\",\n      value: function curve(a, b) {\n        var c = this._options(b);\n\n        return this._drawable(\"curve\", [this.lib.curve(a, c)], c);\n      }\n    }, {\n      key: \"path\",\n      value: function path(a, b) {\n        var c = this._options(b),\n            e = [];\n\n        if (!a) return this._drawable(\"path\", e, c);\n        if (c.fill) if (\"solid\" === c.fillStyle) {\n          e.push({\n            type: \"path2Dfill\",\n            path: a\n          });\n        } else {\n          var _b16 = this._computePathSize(a);\n\n          var _d9 = [0, _b16[0], _b16[0], 0],\n              _f16 = [0, 0, _b16[1], _b16[1]],\n              _g12 = this.lib.hachureFillShape(_d9, _f16, c);\n\n          _g12.type = \"path2Dpattern\", _g12.size = _b16, _g12.path = a, e.push(_g12);\n        }\n        return e.push(this.lib.svgPath(a, c)), this._drawable(\"path\", e, c);\n      }\n    }, {\n      key: \"_computePathSize\",\n      value: function _computePathSize(a) {\n        var b = [0, 0];\n        if (self.document) try {\n          var _c17 = \"http://www.w3.org/2000/svg\";\n\n          var _d10 = self.document.createElementNS(_c17, \"svg\");\n\n          _d10.setAttribute(\"width\", \"0\"), _d10.setAttribute(\"height\", \"0\");\n\n          var _e11 = self.document.createElementNS(_c17, \"path\");\n\n          _e11.setAttribute(\"d\", a), _d10.appendChild(_e11), self.document.body.appendChild(_d10);\n\n          var _f17 = _e11.getBBox();\n\n          _f17 && (b[0] = _f17.width || 0, b[1] = _f17.height || 0), self.document.body.removeChild(_d10);\n        } catch (a) {}\n        return b[0] * b[1] || (b = [this.canvas.width || 100, this.canvas.height || 100]), b[0] = j(4 * b[0], this.canvas.width), b[1] = j(4 * b[1], this.canvas.height), b;\n      }\n    }, {\n      key: \"lib\",\n      get: function get() {\n        if (!this._renderer) if (self && self.workly && this.config.async && !this.config.noWorker) {\n          var _a12 = Function.prototype.toString,\n              _b17 = this.config.worklyURL || \"https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js\",\n              _c18 = this.config.roughURL || self._roughScript;\n\n          if (_c18 && _b17) {\n            var _a13 = \"importScripts('\".concat(_b17, \"','\").concat(_c18, \"');\\nworkly.expose(self.rough.createRenderer());\"),\n                _d11 = URL.createObjectURL(new Blob([_a13]));\n\n            this._renderer = workly.proxy(_d11);\n          } else this._renderer = new s();\n        } else this._renderer = new s();\n        return this._renderer;\n      }\n    }]);\n\n    return t;\n  }();\n\n  var u = /*#__PURE__*/function (_t2) {\n    _inherits(u, _t2);\n\n    var _super = _createSuper(u);\n\n    function u() {\n      _classCallCheck(this, u);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(u, [{\n      key: \"line\",\n      value: function () {\n        var _line2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(a, b, c, d, e) {\n          var f;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  f = this._options(e);\n                  _context.t0 = this;\n                  _context.next = 4;\n                  return this.lib.line(a, b, c, d, f);\n\n                case 4:\n                  _context.t1 = _context.sent;\n                  _context.t2 = [_context.t1];\n                  _context.t3 = f;\n                  return _context.abrupt(\"return\", _context.t0._drawable.call(_context.t0, \"line\", _context.t2, _context.t3));\n\n                case 8:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function line(_x, _x2, _x3, _x4, _x5) {\n          return _line2.apply(this, arguments);\n        }\n\n        return line;\n      }()\n    }, {\n      key: \"rectangle\",\n      value: function () {\n        var _rectangle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(a, b, c, d, e) {\n          var f, g, _e12, _h11;\n\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  f = this._options(e), g = [];\n\n                  if (!f.fill) {\n                    _context2.next = 16;\n                    break;\n                  }\n\n                  _e12 = [a, a + c, a + c, a], _h11 = [b, b, b + d, b + d];\n\n                  if (!(\"solid\" === f.fillStyle)) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  _context2.t0 = g;\n                  _context2.next = 7;\n                  return this.lib.solidFillShape(_e12, _h11, f);\n\n                case 7:\n                  _context2.t1 = _context2.sent;\n\n                  _context2.t0.push.call(_context2.t0, _context2.t1);\n\n                  _context2.next = 16;\n                  break;\n\n                case 11:\n                  _context2.t2 = g;\n                  _context2.next = 14;\n                  return this.lib.hachureFillShape(_e12, _h11, f);\n\n                case 14:\n                  _context2.t3 = _context2.sent;\n\n                  _context2.t2.push.call(_context2.t2, _context2.t3);\n\n                case 16:\n                  _context2.t4 = g;\n                  _context2.next = 19;\n                  return this.lib.rectangle(a, b, c, d, f);\n\n                case 19:\n                  _context2.t5 = _context2.sent;\n\n                  _context2.t4.push.call(_context2.t4, _context2.t5);\n\n                  return _context2.abrupt(\"return\", this._drawable(\"rectangle\", g, f));\n\n                case 22:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function rectangle(_x6, _x7, _x8, _x9, _x10) {\n          return _rectangle.apply(this, arguments);\n        }\n\n        return rectangle;\n      }()\n    }, {\n      key: \"ellipse\",\n      value: function () {\n        var _ellipse2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(a, b, c, d, e) {\n          var f, g, _e13;\n\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  f = this._options(e), g = [];\n\n                  if (!f.fill) {\n                    _context3.next = 14;\n                    break;\n                  }\n\n                  if (!(\"solid\" === f.fillStyle)) {\n                    _context3.next = 9;\n                    break;\n                  }\n\n                  _context3.next = 5;\n                  return this.lib.ellipse(a, b, c, d, f);\n\n                case 5:\n                  _e13 = _context3.sent;\n                  _e13.type = \"fillPath\", g.push(_e13);\n                  _context3.next = 14;\n                  break;\n\n                case 9:\n                  _context3.t0 = g;\n                  _context3.next = 12;\n                  return this.lib.hachureFillEllipse(a, b, c, d, f);\n\n                case 12:\n                  _context3.t1 = _context3.sent;\n\n                  _context3.t0.push.call(_context3.t0, _context3.t1);\n\n                case 14:\n                  _context3.t2 = g;\n                  _context3.next = 17;\n                  return this.lib.ellipse(a, b, c, d, f);\n\n                case 17:\n                  _context3.t3 = _context3.sent;\n\n                  _context3.t2.push.call(_context3.t2, _context3.t3);\n\n                  return _context3.abrupt(\"return\", this._drawable(\"ellipse\", g, f));\n\n                case 20:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function ellipse(_x11, _x12, _x13, _x14, _x15) {\n          return _ellipse2.apply(this, arguments);\n        }\n\n        return ellipse;\n      }()\n    }, {\n      key: \"circle\",\n      value: function () {\n        var _circle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(a, b, c, d) {\n          var e;\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return this.ellipse(a, b, c, c, d);\n\n                case 2:\n                  e = _context4.sent;\n                  return _context4.abrupt(\"return\", (e.shape = \"circle\", e));\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function circle(_x16, _x17, _x18, _x19) {\n          return _circle.apply(this, arguments);\n        }\n\n        return circle;\n      }()\n    }, {\n      key: \"linearPath\",\n      value: function () {\n        var _linearPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  c = this._options(b);\n                  _context5.t0 = this;\n                  _context5.next = 4;\n                  return this.lib.linearPath(a, !1, c);\n\n                case 4:\n                  _context5.t1 = _context5.sent;\n                  _context5.t2 = [_context5.t1];\n                  _context5.t3 = c;\n                  return _context5.abrupt(\"return\", _context5.t0._drawable.call(_context5.t0, \"linearPath\", _context5.t2, _context5.t3));\n\n                case 8:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function linearPath(_x20, _x21) {\n          return _linearPath.apply(this, arguments);\n        }\n\n        return linearPath;\n      }()\n    }, {\n      key: \"polygon\",\n      value: function () {\n        var _polygon = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(a, b) {\n          var c, d, _b18, _e14, _iterator5, _step5, _c19;\n\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  c = this._options(b), d = [];\n\n                  if (!c.fill) {\n                    _context6.next = 18;\n                    break;\n                  }\n\n                  _b18 = [], _e14 = [];\n                  _iterator5 = _createForOfIteratorHelper(a);\n\n                  try {\n                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                      _c19 = _step5.value;\n                      _b18.push(_c19[0]), _e14.push(_c19[1]);\n                    }\n                  } catch (err) {\n                    _iterator5.e(err);\n                  } finally {\n                    _iterator5.f();\n                  }\n\n                  if (!(\"solid\" === c.fillStyle)) {\n                    _context6.next = 13;\n                    break;\n                  }\n\n                  _context6.t0 = d;\n                  _context6.next = 9;\n                  return this.lib.solidFillShape(_b18, _e14, c);\n\n                case 9:\n                  _context6.t1 = _context6.sent;\n\n                  _context6.t0.push.call(_context6.t0, _context6.t1);\n\n                  _context6.next = 18;\n                  break;\n\n                case 13:\n                  _context6.t2 = d;\n                  _context6.next = 16;\n                  return this.lib.hachureFillShape(_b18, _e14, c);\n\n                case 16:\n                  _context6.t3 = _context6.sent;\n\n                  _context6.t2.push.call(_context6.t2, _context6.t3);\n\n                case 18:\n                  _context6.t4 = d;\n                  _context6.next = 21;\n                  return this.lib.linearPath(a, !0, c);\n\n                case 21:\n                  _context6.t5 = _context6.sent;\n\n                  _context6.t4.push.call(_context6.t4, _context6.t5);\n\n                  return _context6.abrupt(\"return\", this._drawable(\"polygon\", d, c));\n\n                case 24:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function polygon(_x22, _x23) {\n          return _polygon.apply(this, arguments);\n        }\n\n        return polygon;\n      }()\n    }, {\n      key: \"arc\",\n      value: function () {\n        var _arc2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(a, b, c, d, e, f, g, h) {\n          var i, j, _g13;\n\n          return regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  i = this._options(h), j = [];\n\n                  if (!(g && i.fill)) {\n                    _context7.next = 14;\n                    break;\n                  }\n\n                  if (!(\"solid\" === i.fillStyle)) {\n                    _context7.next = 9;\n                    break;\n                  }\n\n                  _context7.next = 5;\n                  return this.lib.arc(a, b, c, d, e, f, !0, !1, i);\n\n                case 5:\n                  _g13 = _context7.sent;\n                  _g13.type = \"fillPath\", j.push(_g13);\n                  _context7.next = 14;\n                  break;\n\n                case 9:\n                  _context7.t0 = j;\n                  _context7.next = 12;\n                  return this.lib.hachureFillArc(a, b, c, d, e, f, i);\n\n                case 12:\n                  _context7.t1 = _context7.sent;\n\n                  _context7.t0.push.call(_context7.t0, _context7.t1);\n\n                case 14:\n                  _context7.t2 = j;\n                  _context7.next = 17;\n                  return this.lib.arc(a, b, c, d, e, f, g, !0, i);\n\n                case 17:\n                  _context7.t3 = _context7.sent;\n\n                  _context7.t2.push.call(_context7.t2, _context7.t3);\n\n                  return _context7.abrupt(\"return\", this._drawable(\"arc\", j, i));\n\n                case 20:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, this);\n        }));\n\n        function arc(_x24, _x25, _x26, _x27, _x28, _x29, _x30, _x31) {\n          return _arc2.apply(this, arguments);\n        }\n\n        return arc;\n      }()\n    }, {\n      key: \"curve\",\n      value: function () {\n        var _curve2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  c = this._options(b);\n                  _context8.t0 = this;\n                  _context8.next = 4;\n                  return this.lib.curve(a, c);\n\n                case 4:\n                  _context8.t1 = _context8.sent;\n                  _context8.t2 = [_context8.t1];\n                  _context8.t3 = c;\n                  return _context8.abrupt(\"return\", _context8.t0._drawable.call(_context8.t0, \"curve\", _context8.t2, _context8.t3));\n\n                case 8:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8, this);\n        }));\n\n        function curve(_x32, _x33) {\n          return _curve2.apply(this, arguments);\n        }\n\n        return curve;\n      }()\n    }, {\n      key: \"path\",\n      value: function () {\n        var _path = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(a, b) {\n          var c, e, _b19, _d12, _f18, _g14;\n\n          return regeneratorRuntime.wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  c = this._options(b), e = [];\n\n                  if (a) {\n                    _context9.next = 3;\n                    break;\n                  }\n\n                  return _context9.abrupt(\"return\", this._drawable(\"path\", e, c));\n\n                case 3:\n                  if (!c.fill) {\n                    _context9.next = 15;\n                    break;\n                  }\n\n                  if (!(\"solid\" === c.fillStyle)) {\n                    _context9.next = 8;\n                    break;\n                  }\n\n                  e.push({\n                    type: \"path2Dfill\",\n                    path: a\n                  });\n                  _context9.next = 15;\n                  break;\n\n                case 8:\n                  _b19 = this._computePathSize(a);\n                  _d12 = [0, _b19[0], _b19[0], 0];\n                  _f18 = [0, 0, _b19[1], _b19[1]];\n                  _context9.next = 13;\n                  return this.lib.hachureFillShape(_d12, _f18, c);\n\n                case 13:\n                  _g14 = _context9.sent;\n                  _g14.type = \"path2Dpattern\", _g14.size = _b19, _g14.path = a, e.push(_g14);\n\n                case 15:\n                  _context9.t0 = e;\n                  _context9.next = 18;\n                  return this.lib.svgPath(a, c);\n\n                case 18:\n                  _context9.t1 = _context9.sent;\n\n                  _context9.t0.push.call(_context9.t0, _context9.t1);\n\n                  return _context9.abrupt(\"return\", this._drawable(\"path\", e, c));\n\n                case 21:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9, this);\n        }));\n\n        function path(_x34, _x35) {\n          return _path.apply(this, arguments);\n        }\n\n        return path;\n      }()\n    }]);\n\n    return u;\n  }(t);\n\n  var v = /*#__PURE__*/function () {\n    function v(a, b) {\n      _classCallCheck(this, v);\n\n      this.canvas = a, this.ctx = this.canvas.getContext(\"2d\"), this._init(b);\n    }\n\n    _createClass(v, [{\n      key: \"_init\",\n      value: function _init(a) {\n        this.gen = new t(a, this.canvas);\n      }\n    }, {\n      key: \"line\",\n      value: function line(a, b, c, e, f) {\n        var g = this.gen.line(a, b, c, e, f);\n        return this.draw(g), g;\n      }\n    }, {\n      key: \"rectangle\",\n      value: function rectangle(a, b, c, e, f) {\n        var g = this.gen.rectangle(a, b, c, e, f);\n        return this.draw(g), g;\n      }\n    }, {\n      key: \"ellipse\",\n      value: function ellipse(a, b, c, e, f) {\n        var g = this.gen.ellipse(a, b, c, e, f);\n        return this.draw(g), g;\n      }\n    }, {\n      key: \"circle\",\n      value: function circle(a, b, c, e) {\n        var f = this.gen.circle(a, b, c, e);\n        return this.draw(f), f;\n      }\n    }, {\n      key: \"linearPath\",\n      value: function linearPath(a, b) {\n        var c = this.gen.linearPath(a, b);\n        return this.draw(c), c;\n      }\n    }, {\n      key: \"polygon\",\n      value: function polygon(a, b) {\n        var c = this.gen.polygon(a, b);\n        return this.draw(c), c;\n      }\n    }, {\n      key: \"arc\",\n      value: function arc(a, b, c, e, f, g, h, i) {\n        var j = this.gen.arc(a, b, c, e, f, g, h, i);\n        return this.draw(j), j;\n      }\n    }, {\n      key: \"curve\",\n      value: function curve(a, b) {\n        var c = this.gen.curve(a, b);\n        return this.draw(c), c;\n      }\n    }, {\n      key: \"path\",\n      value: function path(a, b) {\n        var c = this.gen.path(a, b);\n        return this.draw(c), c;\n      }\n    }, {\n      key: \"draw\",\n      value: function draw(a) {\n        var b = a.sets || [],\n            c = a.options || this.gen.defaultOptions,\n            d = this.ctx;\n\n        var _iterator6 = _createForOfIteratorHelper(b),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _e15 = _step6.value;\n\n            switch (_e15.type) {\n              case \"path\":\n                d.save(), d.strokeStyle = c.stroke, d.lineWidth = c.strokeWidth, this._drawToContext(d, _e15), d.restore();\n                break;\n\n              case \"fillPath\":\n                d.save(), d.fillStyle = c.fill, this._drawToContext(d, _e15, c), d.restore();\n                break;\n\n              case \"fillSketch\":\n                this._fillSketch(d, _e15, c);\n\n                break;\n\n              case \"path2Dfill\":\n                {\n                  this.ctx.save(), this.ctx.fillStyle = c.fill;\n\n                  var _a14 = new Path2D(_e15.path);\n\n                  this.ctx.fill(_a14), this.ctx.restore();\n                  break;\n                }\n\n              case \"path2Dpattern\":\n                {\n                  var _a15 = _e15.size,\n                      _b20 = document.createElement(\"canvas\");\n\n                  _b20.width = _a15[0], _b20.height = _a15[1], this._fillSketch(_b20.getContext(\"2d\"), _e15, c), this.ctx.save(), this.ctx.fillStyle = this.ctx.createPattern(_b20, \"repeat\");\n\n                  var _d13 = new Path2D(_e15.path);\n\n                  this.ctx.fill(_d13), this.ctx.restore();\n                  break;\n                }\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }, {\n      key: \"_fillSketch\",\n      value: function _fillSketch(a, b, c) {\n        var d = c.fillWeight;\n        0 > d && (d = c.strokeWidth / 2), a.save(), a.strokeStyle = c.fill, a.lineWidth = d, this._drawToContext(a, b), a.restore();\n      }\n    }, {\n      key: \"_drawToContext\",\n      value: function _drawToContext(a, b) {\n        a.beginPath();\n\n        var _iterator7 = _createForOfIteratorHelper(b.ops),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _c20 = _step7.value;\n            var _b21 = _c20.data;\n\n            switch (_c20.op) {\n              case \"move\":\n                a.moveTo(_b21[0], _b21[1]);\n                break;\n\n              case \"bcurveTo\":\n                a.bezierCurveTo(_b21[0], _b21[1], _b21[2], _b21[3], _b21[4], _b21[5]);\n                break;\n\n              case \"qcurveTo\":\n                a.quadraticCurveTo(_b21[0], _b21[1], _b21[2], _b21[3]);\n                break;\n\n              case \"lineTo\":\n                a.lineTo(_b21[0], _b21[1]);\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        \"fillPath\" === b.type ? a.fill() : a.stroke();\n      }\n    }, {\n      key: \"generator\",\n      get: function get() {\n        return this.gen;\n      }\n    }], [{\n      key: \"createRenderer\",\n      value: function createRenderer() {\n        return new s();\n      }\n    }]);\n\n    return v;\n  }();\n\n  var w = /*#__PURE__*/function (_v2) {\n    _inherits(w, _v2);\n\n    var _super2 = _createSuper(w);\n\n    function w() {\n      _classCallCheck(this, w);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(w, [{\n      key: \"_init\",\n      value: function _init(a) {\n        this.gen = new u(a, this.canvas);\n      }\n    }, {\n      key: \"line\",\n      value: function () {\n        var _line3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(a, b, c, e, f) {\n          var g;\n          return regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  _context10.next = 2;\n                  return this.gen.line(a, b, c, e, f);\n\n                case 2:\n                  g = _context10.sent;\n                  return _context10.abrupt(\"return\", (this.draw(g), g));\n\n                case 4:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10, this);\n        }));\n\n        function line(_x36, _x37, _x38, _x39, _x40) {\n          return _line3.apply(this, arguments);\n        }\n\n        return line;\n      }()\n    }, {\n      key: \"rectangle\",\n      value: function () {\n        var _rectangle2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(a, b, c, e, f) {\n          var g;\n          return regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.next = 2;\n                  return this.gen.rectangle(a, b, c, e, f);\n\n                case 2:\n                  g = _context11.sent;\n                  return _context11.abrupt(\"return\", (this.draw(g), g));\n\n                case 4:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, this);\n        }));\n\n        function rectangle(_x41, _x42, _x43, _x44, _x45) {\n          return _rectangle2.apply(this, arguments);\n        }\n\n        return rectangle;\n      }()\n    }, {\n      key: \"ellipse\",\n      value: function () {\n        var _ellipse3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(a, b, c, e, f) {\n          var g;\n          return regeneratorRuntime.wrap(function _callee12$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  _context12.next = 2;\n                  return this.gen.ellipse(a, b, c, e, f);\n\n                case 2:\n                  g = _context12.sent;\n                  return _context12.abrupt(\"return\", (this.draw(g), g));\n\n                case 4:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }, _callee12, this);\n        }));\n\n        function ellipse(_x46, _x47, _x48, _x49, _x50) {\n          return _ellipse3.apply(this, arguments);\n        }\n\n        return ellipse;\n      }()\n    }, {\n      key: \"circle\",\n      value: function () {\n        var _circle2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(a, b, c, e) {\n          var f;\n          return regeneratorRuntime.wrap(function _callee13$(_context13) {\n            while (1) {\n              switch (_context13.prev = _context13.next) {\n                case 0:\n                  _context13.next = 2;\n                  return this.gen.circle(a, b, c, e);\n\n                case 2:\n                  f = _context13.sent;\n                  return _context13.abrupt(\"return\", (this.draw(f), f));\n\n                case 4:\n                case \"end\":\n                  return _context13.stop();\n              }\n            }\n          }, _callee13, this);\n        }));\n\n        function circle(_x51, _x52, _x53, _x54) {\n          return _circle2.apply(this, arguments);\n        }\n\n        return circle;\n      }()\n    }, {\n      key: \"linearPath\",\n      value: function () {\n        var _linearPath2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee14$(_context14) {\n            while (1) {\n              switch (_context14.prev = _context14.next) {\n                case 0:\n                  _context14.next = 2;\n                  return this.gen.linearPath(a, b);\n\n                case 2:\n                  c = _context14.sent;\n                  return _context14.abrupt(\"return\", (this.draw(c), c));\n\n                case 4:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }\n          }, _callee14, this);\n        }));\n\n        function linearPath(_x55, _x56) {\n          return _linearPath2.apply(this, arguments);\n        }\n\n        return linearPath;\n      }()\n    }, {\n      key: \"polygon\",\n      value: function () {\n        var _polygon2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  _context15.next = 2;\n                  return this.gen.polygon(a, b);\n\n                case 2:\n                  c = _context15.sent;\n                  return _context15.abrupt(\"return\", (this.draw(c), c));\n\n                case 4:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15, this);\n        }));\n\n        function polygon(_x57, _x58) {\n          return _polygon2.apply(this, arguments);\n        }\n\n        return polygon;\n      }()\n    }, {\n      key: \"arc\",\n      value: function () {\n        var _arc3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(a, b, c, e, f, g, h, i) {\n          var j;\n          return regeneratorRuntime.wrap(function _callee16$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  _context16.next = 2;\n                  return this.gen.arc(a, b, c, e, f, g, h, i);\n\n                case 2:\n                  j = _context16.sent;\n                  return _context16.abrupt(\"return\", (this.draw(j), j));\n\n                case 4:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }, _callee16, this);\n        }));\n\n        function arc(_x59, _x60, _x61, _x62, _x63, _x64, _x65, _x66) {\n          return _arc3.apply(this, arguments);\n        }\n\n        return arc;\n      }()\n    }, {\n      key: \"curve\",\n      value: function () {\n        var _curve3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee17$(_context17) {\n            while (1) {\n              switch (_context17.prev = _context17.next) {\n                case 0:\n                  _context17.next = 2;\n                  return this.gen.curve(a, b);\n\n                case 2:\n                  c = _context17.sent;\n                  return _context17.abrupt(\"return\", (this.draw(c), c));\n\n                case 4:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }\n          }, _callee17, this);\n        }));\n\n        function curve(_x67, _x68) {\n          return _curve3.apply(this, arguments);\n        }\n\n        return curve;\n      }()\n    }, {\n      key: \"path\",\n      value: function () {\n        var _path2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(a, b) {\n          var c;\n          return regeneratorRuntime.wrap(function _callee18$(_context18) {\n            while (1) {\n              switch (_context18.prev = _context18.next) {\n                case 0:\n                  _context18.next = 2;\n                  return this.gen.path(a, b);\n\n                case 2:\n                  c = _context18.sent;\n                  return _context18.abrupt(\"return\", (this.draw(c), c));\n\n                case 4:\n                case \"end\":\n                  return _context18.stop();\n              }\n            }\n          }, _callee18, this);\n        }));\n\n        function path(_x69, _x70) {\n          return _path2.apply(this, arguments);\n        }\n\n        return path;\n      }()\n    }]);\n\n    return w;\n  }(v);\n\n  var x = {\n    canvas: function canvas(a, b) {\n      return b && b.async ? new w(a, b) : new v(a, b);\n    },\n    createRenderer: function createRenderer() {\n      return v.createRenderer();\n    },\n    generator: function generator(a, b) {\n      return a && a.async ? new u(a, b) : new t(a, b);\n    }\n  };\n  return x;\n}();\n\nvar extend = function extend(base) {\n  for (var _len = arguments.length, extensions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    extensions[_key - 1] = arguments[_key];\n  }\n\n  return Object.assign.apply(Object, [{}, base].concat(extensions));\n};\n\nvar parseColor = function parseColor(_ref) {\n  var h = _ref.h,\n      s = _ref.s,\n      l = _ref.l,\n      a = _ref.a;\n  return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';\n};\n\nvar Color = extend.bind(null, {\n  h: 0,\n  s: 100,\n  l: 100,\n  a: 1\n});\nvar Vector = extend.bind(null, {\n  x: 0,\n  y: 0\n});\nvar Particle = extend.bind(null, {\n  pos: Vector(),\n  vel: Vector(),\n  angle: 0,\n  speed: 0,\n  radius: 0,\n  rotation: 0,\n  color: Color()\n});\nvar colors = [Color({\n  h: 20,\n  s: 100,\n  l: 50\n}), Color({\n  h: 200,\n  l: 50\n}), Color({\n  h: 300,\n  l: 50\n}), Color({\n  h: 100,\n  l: 40\n})];\n\nvar animationLoop = function animationLoop(scope) {\n  if (scope.animation) {\n    scope.animation(animationLoop.bind(null, scope));\n  }\n\n  var ctx = scope.ctx;\n  var canvas = ctx.canvas;\n  var rc = rough.canvas(canvas);\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  scope.particles.map(function (p, i) {\n    p.pos.y -= p.speed;\n\n    if (i % 2) {\n      p.pos.x = p.pos.x + Math.sin(p.angle) * .2;\n    } else {\n      p.pos.x = p.pos.x - Math.cos(p.angle) * .2;\n    }\n\n    p.angle += .01;\n    rc.circle(p.pos.x, p.pos.y, p.radius, {\n      fill: parseColor(p.color),\n      roughness: Math.random() * 1.5,\n      hachureGap: p.hachureGap,\n      hachureAngle: p.hachureAngle\n    });\n    rc.line(p.pos.x, p.pos.y + p.radius * 1.2, p.pos.x, p.pos.y + p.radius / 2, {\n      bowing: Math.random() * 3\n    });\n\n    if (p.pos.y + p.radius * 3 < 0) {\n      p.pos.y = canvas.height + p.radius * 3;\n      p.pos.x = Math.random() * (canvas.width - p.radius);\n    }\n  });\n};\n\nvar scope = {\n  animation: requestAnimationFrame.bind(null),\n  ctx: document.createElement('canvas').getContext('2d'),\n  title: 'Brian Douglas',\n  rotation: 0,\n  particles: []\n};\n~function (scope) {\n  var canvas = scope.ctx.canvas;\n  canvas.id = \"bg_canvas\";\n  canvas.setAttribute(\"style\", \"position:fixed;z-index:-1;left:0;top:0;min-width:100vw;min-height:100vh;background: #e9ebec;\");\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  document.body.appendChild(canvas);\n  var particleCount = 50;\n\n  while (particleCount--) {\n    scope.particles.push(Particle({\n      pos: {\n        x: Math.random() * canvas.width,\n        y: Math.random() * canvas.height\n      },\n      speed: Math.random() + .2,\n      radius: Math.random() * 60 + 20,\n      color: colors[Math.floor(Math.random() * colors.length)],\n      hachureAngle: Math.random() * 90,\n      hachureGap: Math.random() * 8 + 1\n    }));\n  }\n\n  animationLoop(scope);\n}(scope);\n\nif (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n  window.addEventListener('resize', function () {\n    scope.ctx.canvas.width = window.innerWidth;\n    scope.ctx.canvas.height = window.innerHeight;\n  });\n}\n\n//# sourceURL=webpack://%5Bname%5D/./src/js/bg/a7.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/js/bg/a7.js");
/******/ })()
;
});